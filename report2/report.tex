\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,italian]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{tcolorbox}
\usepackage[binary-units]{siunitx}
\usepackage{hyperref}

\usepackage{minted}

\newcommand\source[2]{
	\inputminted[fontsize=\footnotesize,linenos=true,tabsize=4]{#1}{#2}
}

%opening
\title{Interfacciamento di una chitarra e di una pulsantiera ad un PC utilizzando Arduino}
\author{
	Del Duchetto, Francesco\\
	\texttt{francescodelduchetto@gmail.com}
	\and
	Di Luigi, William\\
	\texttt{williamdiluigi@gmail.com}
}

\begin{document}

\maketitle

\begin{abstract}
	La presente relazione descrive i procedimenti che hanno portato gli autori a realizzare un dispositivo elettronico in grado di interfacciare l'uscita analogica di una chitarra elettrica e l'uscita digitale di una pulsantiera con l'ingresso USB di un calcolatore. Il progetto è nato come elaborato nell'ambito del corso di \emph{Programmazione di Sistemi Embedded}.
\end{abstract}

\section{Descrizione sintetica dell'idea del progetto}

Lo scorso anno accademico, Francesco (uno dei due autori) ha sviluppato un software denominato \emph{GuitarDSP} come elaborato del corso di Programmazione ad oggetti \cite{delduchetto2014}. Questo software permette di applicare, dato un file audio, degli effetti ``in cascata'' dando la possibilità all'utente di scegliere:
\begin{itemize}
	\item Quanti effetti applicare: tramite un'apposita interfaccia grafica è possibile aggiungere/eliminare effetti.
	\item In che ordine applicare gli effetti: c'è chiaramente una grossa differenza tra applicare un delay dopo una distorsione e applicare invece una distorsione ad un segnale che ha delay.
	\item Quali parametri dare a ciascuno degli effetti: ogni effetto espone un'interfaccia che ``istruisce'' la GUI in modo che mostri opportuni slider con i corretti valori minimi e massimi.
\end{itemize}

Il software GuitarDSP è stato completato e consegnato con successo. Tuttavia, la praticità del suo utilizzo è stata fin da subito gravemente pregiudicata dalla necessità di avere un file audio piuttosto che una connessione diretta tra la chitarra ed il software.

Nella sezione conclusiva della relazione, l'autore di GuitarDSP si proponeva di lavorare ad una versione \emph{2.0} che avrebbe introdotto una modalità di input appositamente studiata per permettere di applicare gli effetti su uno stream esterno piuttosto che su un file audio. È ora arrivato il momento di implementare questa nuova funzionalità.

\subsection{Aspetti salienti relativamente al corso}
Il software GuitarDSP, essendo sviluppato nell'ambito di un corso di programmazione ad oggetti, implicava la trattazione di aspetti relativi alla buona progettazione del software, al riuso dei componenti, e così via. In questo caso invece, per un elaborato di sistemi embedded, gli aspetti salienti trattati sono:
\begin{itemize}
	\item La conversione analogico-digitale: la chitarra produce in uscita un segnale elettrico analogico, che dobbiamo interpretare misurandone la tensione.
	\item La comunicazione tra Arduino e il PC che elabora gli effetti.
	\item La gestione delle problematiche di un sistema \textit{near real time}.
	\item La codifica e decodifica di unità di informazione (che contengono il sample audio e il pulsante premuto).
\end{itemize}

\section{Modello semplificato}
Il modello semplificato del progetto realizzato si può descrivere tramite la seguente illustrazione:

\begin{center}
    \includegraphics[width=0.9\linewidth]{fig1.png}
\end{center}

Arduino viene usato per interfacciare i dati provenienti dalla chitarra su \texttt{input0} e dalla pulsantiera su \texttt{input1} attraverso la porta seriale, \texttt{output0}. L'interfaccia viene poi utilizzata dal software GuitarDSP che elabora l'audio prodotto dalla chitarra applicandogli effetti quali: distortion, reverb, e così via. I dati acquisiti con la pulsantiera vengono utilizzati per decidere quali effetti attivare o disattivare. Possiamo quindi considerare, nella nostra modellazione, le seguenti entità distinte:\begin{center}
    \begin{minipage}[t]{0.4\textwidth}
        \begin{tcolorbox}
        Un'interfaccia su Arduino che raccoglie i dati dai sensori di input, li elabora e comunica tramite la porta seriale.
        \end{tcolorbox}
    \end{minipage}
    \begin{minipage}[t]{0.5\textwidth}
        \begin{tcolorbox}
        Un'interfaccia sul PC che ascolta le comunicazioni provenienti dalla porta seriale, fa delle elaborazioni e produce un output tramite degli attuatori.
        \end{tcolorbox}
    \end{minipage}
\end{center}

Le due entità agiscono autonomamente, ognuna seguendo i propri obiettivi locali, ma collaborano comunicando tramite il cavo seriale per svolgere un compito globale.

Ciò che stiamo modellando quindi è un sistema multi-agente, composto da due agenti: uno più potente, che si occupa di effettuare i task più dispendiosi a livello di CPU, e l'altro meno potente, che raccoglie i dati dai sensori e li fornisce al primo.

La suddivisione in entità separate rende indipendenti gli agenti coinvolti e permette di estendere il sistema senza dover compromettere il funzionamento generale. Ognuno dei due agenti coinvolti non è a conoscenza dei dettagli implementativi e strutturali dell'altro per cui possiamo, ad esempio, sostituire il sottosistema \textsc{Chitarra-Pulsantiera-Arduino} con una tastiera elettronica o un microfono, oppure aggiungere un nuovo algoritmo di elaborazione dell'audio, il tutto senza compromettere la stabilità dell'intero sistema.

L'unica cosa che vincola il comportamento degli agenti è il protocollo utilizzato per lo scambio di informazioni, ovvero il modo in cui i sottosistemi comunicano: fintantoché viene rispettato il protocollo, essi riusciranno a collaborare al funzionamento globale.

\subsection{Requisiti e funzionalità}
I requisiti globali del sistema sono:
\begin{itemize}
    \item ``Ascoltare'' l'audio analogico proveniente dalla chitarra.
    \item Rilevare la pressione dei pulsanti.
    \item Elaborare il suono applicando degli effetti.
    \item ``Suonare'' l'audio risultante con poco ritardo (\textit{near real time}).
    \item Riuscire a gestire una comunicazione efficiente tra le entità.
\end{itemize}

\noindent
Possiamo separare logicamente i requisiti del sistema in due sottosistemi:
\begin{itemize}
    \item Sottosistema \textsc{Chitarra-Pulsantiera-Arduino}:
    \begin{enumerate}
        \item Lettura continua dell'audio analogico e campionamento, evitando il più possibile di perdere qualità.
        \item Rilevazione della pressione (asincrona) dei pulsanti.
        \item Spedizione di tutti i dati raccolti tramite l'uscita seriale in modo che arrivino integri al destinatario.
    \end{enumerate}
    \item Sottosistema \textsc{Computer}:
    \begin{enumerate}
        \item Lettura dei dati in arrivo sulla porta USB ``distinguendo'' i dati audio da quelli relativi ai pulsanti.
        \item Elaborazione del suono e applicazione gli effetti.
        \item Modifica della pila di effetti da applicare, in base ai pulsanti premuti.
        \item Invio del suono elaborato sulla linea di output.
    \end{enumerate}
\end{itemize}

Tutti questi compiti devono essere svolti in modo da rendere usabile il sistema, quindi la latenza tra il suono prodotto dalla chitarra e quello in uscita dal PC non deve essere percettibile e il suono deve essere fedele e coerente con gli effetti selezionati.

\section{Architettura complessiva del sistema}
L'architettura complessiva del sistema creato si può inquadrare nel \textit{Producer-consumer pattern}. Infatti, il sottosistema \textsc{Chitarra-Pulsantiera-Arduino} è un \textit{producer} dal momento che deve creare dei dati, mentre il sottosistema \textsc{Computer} è un \textit{consumer} ed ha il compito di usare i dati che arrivano.

Dopo aver stabilito come il nostro sistema è architettato e i requisiti che deve rispettare, notiamo che per costruirne uno funzionante dobbiamo prima gestire il problema del produttore/consumatore.

\subsection{Problema del produttore/consumatore}
In informatica il problema del produttore/consumatore è un esempio classico di sincronizzazione tra due processi. Il processo \textit{producer} ha il compito di generare continuativamente dei dati, mettendoli di volta in volta in un buffer comune. Il processo \textit{consumer}, dal canto suo, ha il compito di elaborare i dati del buffer estraendoli uno per volta dal buffer.

Nel nostro caso, per garantire un'alta qualità dell'audio, il producer deve generare quanti più dati possibili (magari evitando di eccedere i \num{44100} campioni al secondo, che sono lo standard nelle registrazioni audio). Il consumer, indipendentemente dalla frequenza del producer, consumerà i dati ad una frequenza specifica (decisa in anticipo) che corrisponderà alla frequenza di riproduzione dell'audio.

Come accennato nella sezione precedente, il nostro sistema ha il requisito del near real time. È intuitivo quindi capire che la soluzione al problema del produttore/consumatore è, nel nostro caso specifico, quella di \textit{concordare una frequenza} comune ad entrambi in modo da affaticare il meno possibile il buffer condiviso.

Dal momento che Arduino risulta essere il collo di bottiglia del sistema, a causa del processore a \SI{16}{\mega\hertz}, è opportuno scegliere la frequenza più alta alla quale il \textit{producer} è in grado di spedire i dati.

\subsection{Campionamento dell'audio}
La lettura dell'audio in input è una funzione cardine del nostro sistema perciò abbiamo speso molto tempo nel cercare il modo migliore per campionare l'audio (per approfondimenti guardare nella sezione \textbf{Test effettuati e discussione}).

La frequenza di campionamento è il numero di campioni prelevati al secondo e si misura in Hertz (\si{\hertz}).
La scelta della frequenza di campionamento del segnale audio è un fattore molto importante nella nostra applicazione per ottenere in uscita una buona qualità audio. Considerando che nei CD audio è pari a \SI{44.1}{\kilo\hertz} mentre nelle linee telefoniche è \SI{8}{\kilo\hertz}, possiamo dire che per noi una frequenza accettabile si aggira tra questi due valori, avvicinandosi il più possibile al primo.

Inizialmente abbiamo provato ad implementare il campionamento audio nel modo più immediato, cioè usando la funzione \texttt{analogRead()} fornita dalle librerie di Arduino. Abbiamo subito notato che facendo in questo modo la frequenza ottenuta era molto bassa, quindi era necessario prendere un'altra direzione.

Abbiamo quindi deciso di utilizzare il convertitore digitale analogico (ADC) presente su Arduino. Possiamo impostare l'ADC in modo da fargli leggere uno specifico pin analogico (nel nostro caso \texttt{A0}) con una determinata frequenza. Questo è il modo più adatto al nostro scopo dato che dobbiamo leggere continuamente i campioni dal pin \texttt{A0}, non a fronte di uno specifico evento, e nel modo più veloce possibile.

Come spiegato più avanti nella sezione dei test, siamo comunque limitati nella frequenza di campionamento per via del tempo di scrittura del valore sulla seriale e del rumore sull'input, che si fa sentire quando leggiamo velocemente. La velocità massima che abbiamo ottenuto si aggira intorno ai \SI{14}{\kilo\hertz}, ma comunque non siamo riusciti ad ottenere un suono del tutto privo di interferenze.

\subsection{Applicazione degli effetti e riproduzione dell'audio}
La parte di elaborazione del suono e riproduzione è stata demandata ad un computer, che a differenza della scheda Arduino Uno riesce a gestire questo compito computazionalmente oneroso. L'applicazione originale GuitarDSP è stata modificata affinché fosse in grado di leggere uno stream di byte dalla porta seriale. Inoltre è stata implementata la possibilità di spegnimento/accensione degli effetti selezionati utilizzando i pulsanti presenti sulla chitarra. La parte di riproduzione del segnale audio è stata lasciata invariata a parte la scelta della frequenza con cui aprire la linea audio, la quale deve essere uguale alla frequenza di campionamento.

\subsection{Modellazione dei pulsanti}
L'idea iniziale per la realizzazione della pulsantiera era quella di registrare ciascun pin digitale come interrupt attraverso la chiamata \href{http://www.arduino.cc/en/Reference/AttachInterrupt}{\texttt{attachInterrupt()}}. Questo sarebbe stato possibile se avessimo utilizzato \emph{Arduino Due}, che permette di associare un interrupt a tutti i pin; avendo invece un microcontrollore grossomodo equivalente ad Arduino Uno, avevamo la possibilità di usare la funzione \texttt{attachInterrupt()} su al più due pin.

A causa di questa limitazione, abbiamo dovuto trovare una soluzione diversa. È possibile utilizzare interrupt per il cambio di stato dei pin (su tutti i pin) attraverso le \emph{Pin Change Interrupt Requests}\cite{allinterrupts}, a patto di avere però due soli interrupt che gestiscono gli \num{8} pulsanti.

\section{Struttura, comportamento ed interazione delle varie parti}
Per strutturare il nostro sistema abbiamo attinto a molte informazioni utili dall'instructable \emph{Arduino Audio Input}\cite{arduinoinput}. Nello specifico, abbiamo riutilizzato il circuito consigliato dall'autore modificandolo in modo da usare l'alimentazione fornita da Arduino piuttosto che quella fornita da due batterie esterne da \SI{9}{\volt}. In questo modo il circuito, che deve essere montato sulla chitarra, risulta più compatto e non dobbiamo preoccuparci di cambiare le batterie quando si scaricano. Inoltre nel suddetto instructable abbiamo trovato diversi spunti per ottimizzare il campionamento dell'audio.

\newpage
\subsection{Diagrammi degli stati}
\noindent
Sottosistema \textsc{Chitarra-Pulsantiera-Arduino}:

\vspace{3mm}

\fbox{\includegraphics[width=\textwidth]{stati1.pdf}}

\vspace{2mm}

\noindent
Sottosistema \textsc{Computer}:

\vspace{3mm}

\fbox{\includegraphics[width=\textwidth]{stati2.pdf}}

\subsection{Struttura codice Arduino}
La parte di codice embedded sul microcontrollore non è strutturata in classi perché abbiamo la necessità che essa vada il più veloce possibile. Il loop principale del programma è vuoto e l'esecuzione di codice è scatenata esclusivamente dagli interrupt (\emph{interrupt driven}). Nello specifico, abbiamo:
\begin{itemize}
	\item Un interrupt sincrono che viene chiamato dall'ADC non appena è disponibile un nuovo campione da leggere. È sincrono dal momento che l'ADC campiona ad una frequenza fissata.
	\item Un interrupt asincrono che viene invocato a fronte della pressione di uno dei pulsanti \texttt{D0, D1, \dots, D7} sulla scheda.
	\item Un interrupt asincrono che viene invocato a fronte della pressione di uno dei pulsanti \texttt{D8, D9, \dots, D13} sulla scheda.
\end{itemize}

La struttura quindi può essere vista come quella di un sistema ad eventi, in cui gli eventi sono gestiti dagli appositi interrupt handler che quindi sono le reazioni agli specifici eventi.

\subsection{Circuito elettronico}
Ricordando che i pin analogici di Arduino permettono di leggere valori di tensione compresi tra \SI{0}{\volt} e \SI{5}{\volt}, per poter campionare adeguatamente il segnale audio proveniente dalla chitarra abbiamo dovuto gestire due principali problematiche:
\begin{itemize}
    \item Nei segnali audio la tensione assume valori sia positivi che negativi.
    \item Il segnale in uscita dalla chitarra non essendo amplificato assume valori di picco dell'ordine dei \SI{200}{\milli\volt}, rendendo difficile ricostruire con precisione il segnale.
\end{itemize}

Non potendo collegare direttamente l'uscita della chitarra ad un pin di Arduino, abbiamo progettato e costruito un circuito che trasforma il segnale originario in un segnale adeguato alle esigenze del microcontrollore. Il circuito trasla il segnale dal range \SI{+-200}{\milli\volt} al range \num{0}-\SI{5}{\volt}, centrandolo in \SI{2.5}{\volt} e amplificandolo di un fattore circa pari a \num{10}.

\newpage
\subsubsection{Prototipo in Multisim}
Questo è il circuito che abbiamo progettato su Multisim\footnote{\url{http://www.ni.com/multisim}} prima di cablarlo sulla scheda di prototipazione:

\begin{center}
\includegraphics[width=0.9\textwidth]{screen.png}
\end{center}

$V_1$ è un oscilloscopio che simula il suono proveniente dalla chitarra. \texttt{U3A} è un amplificatore operazionale (modello \texttt{TLC272CP}) collegato in configurazione invertente la cui tensione in uscita sarà: $$V_{\mathrm{out}} = V_2 - \frac{R_2}{R_1} \cdot V_1$$

Le resistenze $R_1$ e $R_2$ quindi servono per regolare il fattore di amplificazione del segnale d'ingresso. Le resistenze $R_3$ ed $R_4$ sono usate invece per fare un partitore di tensione ed ottenere i \SI{2.5}{\volt} per spostare il segnale nel range \num{0}-\SI{5}{\volt}. I condensatori sono stati usati per tagliare via le frequenze di rumore dal segnale di input.

\newpage
Nel grafico seguente vediamo in rosso il segnale $V_1$ di input e in blu il segnale di output:
\vspace{0.1in}

\begin{center}
\includegraphics[width=0.9\textwidth]{screen2.png}
\end{center}

\subsection{Comunicazione Arduino-PC}
La comunicazione tra Arduino e il computer è stato un punto chiave del nostro progetto perché come vedremo la scelta del protocollo di comunicazione influenza molto le performance del sistema. I dati che il microcontrollore deve mandare al computer sono:
\begin{enumerate}
    \item \SI{10}{\bit} di sample (valori tra \num{0} e \num{1024}).
    \item Indice del pulsante premuto (\num{0} per indicare ``nessuno'').
\end{enumerate}

\subsubsection{Comunicazione senza sincronizzazione}
Il primo test effettuato è stato quello di non utilizzare alcun protocollo specifico, ovvero mandare i campioni raccolti senza aggiungere alcun dato di sincronizzazione. Chiaramente questo approccio è quello che permette di raggiungere la maggior velocità di comunicazione visto che mandiamo solamente i dati utili senza aggiungere informazioni non necessarie.

Per scrivere sulla seriale utilizzeremo la funzione \texttt{Serial.write} la quale, a differenza di \texttt{Serial.print}, non codifica il valore in ASCII, cosa che comporterebbe la spedizione di un pacchetto più grande.

La funzione \texttt{Serial.write} lavora con risoluzione di \SI{1}{\byte} quindi per scrivere il sample, grande \SI{10}{\bit}, abbiamo bisogno di scrivere \SI{2}{\byte}. Per i pulsanti invece, che sono \num{8}, ci basta \SI{1}{\byte}. In totale dobbiamo scrivere \SI{3}{\byte}. Dobbiamo chiederci a questo punto in che ordine conviene scrivere questi byte, e se è opportuno mandare ogni volta il byte relativo ai pulsanti o solo quando registriamo una pressione.

Notiamo che l'ordine con cui spediamo i byte non fa molta differenza, l'importante è che sia ben definito in modo che il computer sappia come interpretare i dati che arrivano. Quindi scriviamo prima i due byte del sample (dal più significativo al meno significativo) ed infine accodiamo il byte del pulsante.

L'ultimo byte potremmo decidere di mandarlo solo quando serve, al costo di introdurre una complessità dal lato del PC. Infatti, dopo i \SI{2}{\byte} del sample, c'è da capire se ciò che arriva è \SI{1}{\byte} relativo ai pulsanti oppure il primo byte del prossimo sample. Senza aggiungere ulteriori dati di sincronizzazione non c'è modo per il PC di saperlo. Per questo motivo, dobbiamo mandare sempre un pacchetto grande \SI{3}{\byte}: il terzo byte conterrà il numero del pulsante premuto se ne è stato premuto uno, o un valore stabilito che indica che non c'è alcun dato relativo ai pulsanti.

Questa soluzione, innanzitutto, lascia inutilizzato l'ultimo byte per quasi tutta la comunicazione dato che il segnale della pressione si verifica molto di rado rispetto ai sample che vengono mandati di continuo. Tuttavia la vera criticità di questo protocollo è che manca del tutto la sincronizzazione tra mittente e destinatario: anche assumendo che ogni volta che Arduino avvia la comunicazione il computer sia pronto per leggere (e quindi si sincronizza senza errori usando il primo byte arrivato come primo byte di un pacchetto), non è detto che durante la comunicazione questa sincronizzazione non possa perdersi. Se infatti si verificano delle situazioni impreviste (ad esempio Arduino viene riavviato, il cavo si stacca, e così via) quando viene ristabilita la comunicazione non è detto che il primo byte che arriva sulla porta seriale del computer corrisponda al primo byte di un pacchetto. In situazioni del genere il PC continua a leggere e a fare il suo lavoro ignaro del fatto che i byte che sta usando potrebbero non essere nell'ordine corretto. Per avere un sistema fault-tolerant siamo perciò obbligati ad inserire delle informazioni di sincronizzazione aggiuntive al nostro pacchetto.

\subsubsection{Comunicazione con sincronizzazione}
Iniziamo con l'analizzare il contenuto dei byte nel pacchetto:

\begin{table}[h]
\centering
\begin{tabular}{ccc}
\textsc{high sample}           & \textsc{low sample}           & \textsc{button}                             \\ \hline
\multicolumn{1}{|c|}{$0\, 0\, 0\, 0\, 0\, 0\, ?\, ? $} & \multicolumn{1}{c|}{$?\,?\,?\,?\,?\,?\,?\,?$} & \multicolumn{1}{c|}{$0\,0\,0\,0\,?\,?\,?\,?$} \\ \hline
\multicolumn{3}{c}{$? \in \{0, 1\}$}
\end{tabular}
\end{table}

I primi \SI{16}{\bit} del pacchetto, che rappresentano il sample, sono composti sempre da \num{6} zeri seguiti da \num{10} cifre qualunque. Il terzo byte è invece formato da \num{4} zeri seguiti da \num{4} valori qualunque, perché i pulsanti sono \num{8} e \SI{4}{\bit} bastano per scrivere i numeri da \num{0} a \num{8}.

Osservando come è formato il pacchetto notiamo che possiamo eliminare del tutto il terzo byte, inserendo i \SI{4}{\bit} utili per l'informazione nello spazio libero del primo byte:

\begin{table}[h]
\centering
\begin{tabular}{cc}
\textsc{{\color[HTML]{FE0000}button} + high sample}           & \textsc{low sample}       \\ \hline
\multicolumn{1}{|c|}{${\color[HTML]{FE0000}?\,?\,?\,?}\, 0\, 0\, ?\, ? $} & \multicolumn{1}{c|}{$?\,?\,?\,?\,?\,?\,?\,?$} \\ \hline
\multicolumn{2}{c}{$? \in \{0, 1\}$}
\end{tabular}
\end{table}

\noindent
Questo ci permette, come vedremo in seguito, di poter campionare ad una frequenza maggiore.
\vspace{3mm}

Per quanto riguarda la sincronizzazione dobbiamo inserire in testa al nostro pacchetto dei bit aggiuntivi che siano univoci all'interno dello stesso, in modo che il ricevente sappia stabilire con certezza, per ogni pacchetto ricevuto, quale sia il primo byte e quale il secondo.

Osservando il contenuto del pacchetto possiamo dire che nel primo byte non potremmo mai ottenere il valore \num{255} (\texttt{11111111} in binario) dato che ci sono \SI{2}{\bit} sempre a \num{0}, il secondo byte invece può contenere qualunque valore.

È necessario inserire \SI{2}{\byte} di sincronizzazione, perché se ne mettessimo solo uno potrebbe accadere che il secondo byte del sample venga scambiato, appunto, per uno dei byte di sincronizzazione. Quindi inseriamo, in testa al pacchetto originario, due byte di sincronizzazione con valore \num{255}.

\begin{table}[h]
\centering
\begin{tabular}{cccc}
\textsc{\color[HTML]{FE0000}sync} & \textsc{\color[HTML]{FE0000}sync} & \textsc{button + high sample} & \textsc{low sample}       \\ \hline
\multicolumn{1}{|c|}{\color[HTML]{FE0000}$1\,1\,1\,1\, 1\, 1\, 1\, 1 $} &\multicolumn{1}{|c|}{\color[HTML]{FE0000}$1\,1\,1\,1\, 1\, 1\, 1\, 1 $} &\multicolumn{1}{|c|}{${?\,?\,?\,?}\, 0\, 0\, ?\, ? $} & \multicolumn{1}{c|}{$?\,?\,?\,?\,?\,?\,?\,?$} \\ \hline
\multicolumn{4}{c}{$? \in \{0, 1\}$}
\end{tabular}
\end{table}

Ora, dal lato PC, siamo sicuri che non appena leggiamo due volte \num{255} seguito da un altro valore (diverso da \num{255}), quest'ultimo è il primo byte del nostro pacchetto originario.

\section{Test effettuati, dati e discussione}

\subsection{Frequenza di campionamento}
Nel nostro progetto il \emph{frame rate} utilizzato per aprire una linea audio di output è pari alla frequenza di campionamento con cui prendiamo il segnale della chitarra con Arduino: se così non fosse, il suono che ne verrebbe fuori non sarebbe uguale a quello suonato. Per questo motivo è stato importante per noi riuscire a fare una stima abbastanza precisa della frequenza con cui prendiamo l'audio.

\subsubsection{Test con \texttt{analogRead()}}
Facendo un po' di prove abbiamo visto che per leggere un campione, utilizzando \texttt{analogRead()}, impieghiamo circa \SI{108}{\micro\second} mentre servono \SI{76}{\micro\second} per scrivere sulla linea seriale un pacchetto di \SI{32}{\bit}.

\source{cpp}{write_speed_rel}

\textit{Con questo sketch abbiamo calcolato il tempo che Arduino impiega per scrivere un pacchetto sulla seriale utilizzando la funzione \texttt{Serial.write}. La funzione \texttt{micros()} ritorna il tempo passato dall'avvio di Arduino in microsecondi, con una precisione di \SI{4}{\micro\second}.}

\vspace{3mm}

In totale quindi, per leggere dal pin \texttt{A0} e scrivere sulla seriale impieghiamo circa \SI{184}{\micro\second}. Il processore di Arduino lavora ad una frequenza di \SI{16}{\mega\hertz} (ovvero \num{16e6} cicli al secondo), quindi in \SI{1}{\micro\second} (\SI{e-6}{\second}) esegue \num{16} cicli. Allora il nostro ciclo di campionamento richiede $\num{16 x 184} = \num{2944}$ cicli del processore.

Questo vuol dire che la frequenza massima che possiamo ottenere in questo modo è $\num[quotient-mode = fraction]{16e6 / 2944} = \SI{5434}{\hertz}$, che coincide circa con il valore del frame rate che avevamo trovato empiricamente. Chiaramente una frequenza di \SI{5}{\kilo\hertz} non è accettabile per i nostri requisiti, essendo addirittura più bassa di quella impiegata nelle linee telefoniche. Dobbiamo prendere un'altra strada.

\subsubsection{Test con l'ADC}
Con Arduino abbiamo la possibilità di sfruttare il convertitore analogico-digitale integrato nella scheda, controllandolo a basso livello. Il seguente codice attiva l'ADC:

\source{cpp}{adc_setup_rel}

Alla riga \texttt{12} impostiamo il prescaler per la frequenza di campionamento. Il prescaler è un fattore di divisione che va applicato alla frequenza del processore (\SI{16}{\mega\hertz}), e serve per limitare la velocità con cui l'ADC deve lavorare.

La seguente tabella mostra i valori che possiamo scegliere con le relative frequenze e periodi di campionamento:

\begin{table}[h]
\centering
\begin{tabular}{lll}
\textbf{prescaler} & \textbf{frequenza}                                        & \textbf{periodo}         \\ \hline
2                    & $\SI{8}{\mega\hertz} / 13 \simeq \SI{615.38}{\kilo\hertz}$  & $\SI{1.62}{\micro\second}$ \\
4                    & $\SI{4}{\mega\hertz} / 13 \simeq \SI{307.69}{\kilo\hertz}$  & $\SI{3.25}{\micro\second}$ \\
8                    & $\SI{2}{\mega\hertz} / 13 \simeq \SI{153.84}{\kilo\hertz}$  & $\SI{6.5}{\micro\second}$  \\
16                   & $\SI{1}{\mega\hertz} / 13 \simeq \SI{76.92}{\kilo\hertz}$   & $\SI{13}{\micro\second}$   \\
32                   & $\SI{500}{\kilo\hertz} / 13 \simeq \SI{38.46}{\kilo\hertz}$ & $\SI{26}{\micro\second}$   \\
64                   & $\SI{250}{\kilo\hertz} / 13 \simeq \SI{19.23}{\kilo\hertz}$ & $\SI{52}{\micro\second}$   \\
128                  & $\SI{125}{\kilo\hertz} / 13 \simeq \SI{9.61}{\kilo\hertz}$  & $\SI{104}{\micro\second}$
\end{tabular}
\end{table}

Il valore \num{13} che divide ulteriormente la frequenza è dato dal numero di cicli di clock dell'ADC che il convertitore impiega per leggere un nuovo valore.

Intuitivamente, ci sembra di riuscire ad ottenere in questo modo frequenze molto alte, anche molto più di quelle di cui abbiamo bisogno. Questo potrebbe portarci a scegliere il valore minimo per il prescaler al fine di ottenere una alta qualità audio. Purtroppo però dobbiamo considerare che, aumentando la frequenza, cresce il rumore nei valori letti sul pin e quindi invece di migliorare la qualità del suono la peggioriamo. In ogni caso a noi va più che bene un prescaler uguale a \num{32} che ci da una qualità molto vicina a quella dei CD audio.

Ora dobbiamo tenere conto di un altro fattore che potrebbe limitare la velocità di campionamento: la comunicazione seriale. Come detto in precedenza, i dati raccolti con Arduino devono essere spediti al computer tramite il cavo seriale: se non riusciamo a mandare in tempo tutti i dati che leggiamo siamo costretti ad abbassare la frequenza dell'ADC.

Nelle riga \texttt{14} del codice attiviamo l'interrupt handler del convertitore, questo vuol dire che non appena il convertitore avrà finito di leggere un valore chiamerà una funzione che possiamo definire. Il codice che inseriremo nella funzione sarà eseguito in sezione critica perciò dobbiamo stare attenti a non inserire cicli molto lunghi e computazioni CPU-intensive.

La macro \texttt{ISR} marca la funzione come interrupt handler, in questo caso (\texttt{ADC\_vect}) come handler dell'avvenuta conversione del valore da parte dell'ADC.

\source{cpp}{adc_interrupt_rel}

Nella funzione leggiamo i valori che sono stati campionati dai registri \texttt{ADCL} e \texttt{ADCH}, li inseriamo nel pacchetto e poi li scriviamo sulla seriale. Assumendo che l'operazione più costosa sia la scrittura sulla porta seriale calcoliamo quanto costa scrivere un pacchetto di \SI{4}{\byte} e consideriamo tale valore come lower bound per il costo del nostro interrupt handler.

Il costo per scrivere un pacchetto di \SI{4}{\byte}, che avevamo trovato nel paragrafo precedente, è in media \SI{76}{\micro\second}. Facendo riferimento alla tabella delle frequenze del prescaler, notiamo che (campionando a \SI{19.23}{\kilo\hertz}) l'ADC legge un nuovo sample ogni \SI{52}{\micro\second}.

Se impostassimo un prescaler minore di \num{128}, il risultato che otterremmo sarebbe quello di avere un handler che impiega più del tempo di attesa tra la lettura di un campione e l'altro (e ciò può mettere in attesa l'ADC che vuole leggere un nuovo sample). L'ADC, quindi, non riuscirebbe a leggere ogni volta che gli tocca (ricordiamo che la gestione dell'interrupt avviene in sezione critica).

Questo risultato stronca le nostre speranze sul fatto di ottenere una qualità audio vicina a quella dei CD e ci dice che possiamo ottenere una frequenza che si aggira tra i \SI{19.23}{\kilo\hertz} e i \SI{9.61}{\kilo\hertz}. Empiricamente, abbiamo trovato circa \SI{14.1}{\kilo\hertz}.

\subsubsection{Frame drop}
Volendo, si potrebbe pensare di lasciare nell'interrupt handler solamente il salvataggio nel pacchetto dei valori letti e demandare la scrittura sulla seriale al loop principale. Questo sicuramente permetterebbe all'ADC di campionare alla frequenza giusta, però il loop principale comunque non riuscirebbe a mandare sulla seriale \emph{tutti} i sample letti, per via del tempo necessario alla scrittura. Questo porterebbe al drop di diversi frame.

Possiamo notare inoltre che la situazione peggiorerebbe a causa del fatto che l'interrupt handler ha priorità maggiore del loop: prenderà quindi spesso il controllo durante l'esecuzione del loop stesso. Facendo una prova abbiamo rilevato una frequenza di circa \SI{9}{\kilo\hertz}.

\section{Documentazione fotografica dei passaggi svolti}
\includegraphics[width=\textwidth]{foto_1.jpg}
\includegraphics[width=\textwidth]{foto_2.jpg}
\includegraphics[width=\textwidth]{foto_3.jpg}
\includegraphics[width=\textwidth]{foto_4.jpg}
\includegraphics[width=\textwidth]{foto_5.jpg}
\includegraphics[width=\textwidth]{foto_6.jpg}

\subsection{Video dimostrativo dell'utilizzo del software}
\href{https://www.youtube.com/watch?v=IA0InBlP8UQ}{\includegraphics[width=\textwidth]{foto_7.jpg}}
\url{https://www.youtube.com/watch?v=IA0InBlP8UQ}

\section{Conclusioni}
Possiamo concludere dicendo che la scheda Arduino Uno, o un suo equivalente, non è adatta per modellare il tipo di applicazione che ci eravamo proposti. Principalmente per due motivi:
\begin{enumerate}
	\item Le caratteristiche fisiche e strutturali del microcontrollore non permettono di leggere da un pin analogico ad un'alta frequenza senza generare rumore sul segnale letto.
	\item La frequenza relativamente bassa del processore non permette di sfruttare a pieno la velocità massima della porta seriale, limitando sensibilmente la velocità di comunicazione.
\end{enumerate}

Probabilmente utilizzando un microcontrollore con una CPU più potente e migliori caratteristiche fisiche saremmo riusciti ad ottenere un sistema più conforme ai nostri requisiti.

Impiegando invece un microcomputer, come \emph{Raspberry Pi}, avremmo potuto gestire tutte le funzioni di lettura, elaborazione e riproduzione del suono nello stesso sistema embedded, tagliando quindi via la necessità di comunicare i dati ad un elaboratore esterno ed ottenendo un sistema totalmente autonomo.

\begin{thebibliography}{9}

\bibitem{delduchetto2014}
  Francesco Del Duchetto,
  \emph{Guitar Effect Processor in Java},
  \url{https://drive.google.com/file/d/0B3icasI9ngtyTko4TDZaYjFDNEE/view},
  2014.

\bibitem{allinterrupts}
	\url{http://playground.arduino.cc/Main/PinChangeInterrupt},

\bibitem{arduinoinput}
	\url{http://www.instructables.com/id/Arduino-Audio-Input}.

\end{thebibliography}

\end{document}
